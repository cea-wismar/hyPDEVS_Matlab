
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Hybrid Atomic Object with Simulator Functionalities</title><meta name="generator" content="MATLAB 9.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-12-23"><meta name="DC.source" content="hybridatomic.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Hybrid Atomic Object with Simulator Functionalities</h1><!--introduction--><pre>stored in DEVS_PATH/00-simulator/hybridatomic.p</pre><p>Is provided as p-code.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#3">Description</a></li><li><a href="#4">Superclass</a></li><li><a href="#5">Inherited properties</a></li><li><a href="#6">Properties</a></li><li><a href="#7">Class methods</a></li><li><a href="#9">Z_MSG</a></li><li><a href="#12">Z2_MSG</a></li><li><a href="#15">SE_MSG</a></li></ul></div><p>
<table border=0><tr><td>Based on modified parallel DEVS
algorithms (Zeigler, Schwatinski) and wrapper extension (Deatcu).</td></tr>
<tr><td>All hybrid user defined atomic models have to be derived from class
hybridatomic.</td></tr>
<tr><td>C. Deatcu 2016</td></tr></table>
</p><h2 id="3">Description</h2><p>Class definition file for an <b>associated simulator</b> for hybrid atomic DEVS models. Extends the discrete associated simulator.</p><p>constructor call:  <tt>obj = hybridatomic(name,x,y,s,c_states,elapsed,sysparams)</tt></p><h2 id="4">Superclass</h2><p><tt>atomic</tt></p><h2 id="5">Inherited properties</h2><p><b>inherited from devs:</b></p><div><ul><li><tt>sub_of</tt>    : string, name of the superordinate model --&gt; for debugging purposes</li><li><tt>tnext</tt>     : float, time of next event</li><li><tt>tlast</tt>     : float, time of last event</li><li><tt>name</tt>      : string, (unique) name of this model --&gt; for debugging purposes                 max. 12 characters for "nice" debug-look ;-)</li><li><tt>x</tt>         : structure, set of inport name/input value (cell array) pairs</li><li><tt>y</tt>         : structure, set of outport name/output value (cell array) pairs</li><li><tt>debug_flag</tt>: 0|1|2|3, no messages|messages|steps|visualize x, y, and s (default 0)</li><li><tt>observe_flag</tt>: 0|1, log states of atomic subcomponents or not (default 0)</li></ul></div><p><b>inherited from atomic:</b></p><div><ul><li><tt>s</tt>         : structure, set of states</li><li><tt>elapsed</tt>   : float, time elapsed since last                 transition (only for initialization)</li><li><tt>sysparams</tt> : structure, set of system parameters, can be set only once at instantiation</li><li><tt>observed</tt>  : cell array including time stamps and a copy of s (structure of states)</li></ul></div><h2 id="6">Properties</h2><div><ul><li><tt>c_states</tt>  : vector of continuous state variables</li><li><tt>mealy</tt>     : 1 if it is of Mealy type, 0 if it is of Moore type                 needs to be set by the modeler in constructor method</li><li><tt>num_c_state_events</tt> : number of cont. state events</li><li><tt>event_offset</tt>    : offset in global event location vector</li><li><tt>state_offset</tt>    : offset in global state vector</li><li><tt>output_offset</tt>   : offset in global output vector</li><li><tt>output_length</tt>   : length of output-vector returned by lamda_c</li><li><tt>input_offset</tt>     : input offsets in global x vector</li><li><tt>input_length</tt>     : length of input from global x vector</li></ul></div><h2 id="7">Class methods</h2><p><b>inherited from atomic:</b></p><p><b>Simulation Messages</b></p><div><ul><li><tt>i_msg(obj,gt)</tt>   : initialization message -   sets tlast and calls tafun() of model to calculate tnext</li><li><tt>s_msg(obj,gt,flag)</tt>: star message - called when atomic is   imminent, calls deltaint() and tafun() of model, sets tlast and   tnext</li><li><tt>x_msg(obj,gt)</tt>  : x message - called, if external event   arrives, calls deltaconffun() or deltaextfun() of model</li><li><tt>y_msg(obj,gt)</tt>  : inperpellation y message - calls lambdafun   of model</li></ul></div><p><b>Set Methods for Flags</b></p><div><ul><li><tt>set_debug(obj, debug_flag)</tt>: set flag for debug messages to 0|1|2|3</li><li><tt>set_observe(obj, observe_flag)</tt>: set flag for tracking discrete states to 0|1</li></ul></div><p><b>Set Methods for States</b></p><div><ul><li><tt>set_states(obj, statenames)</tt>: initializes the structure obj.s. with fields defined in statenames</li><li><tt>set.s(obj,svalues)</tt>:          safe setting of state values in s</li></ul></div><p>--------------------------------------------------------------------</p><p><b>Additional methods for hybrid simulation:</b></p><div><ul><li><tt>[obj,gstatvec,gevveclen,outoffs] = z_msg(obj,gt,soff,eoff)</tt> :   z message - vector configuration of hybrid atomics</li><li><tt>obj = z2_msg(obj,gt,ioffs)</tt> : z2 message - second run vector   configuration of hybrid atomics (setting the index of local input   variables)</li><li><tt>[obj,event_flag] = se_msg(obj,te,ye,ie)</tt> : state event message -   is called when a state event occurred somewhere in entire model   (for hybrid simulation only);   if state event occured in THIS model, set event_flag and calculate tnext</li></ul></div><div><ul><li><tt>showall(obj)</tt>                 : display the object</li></ul></div><h2 id="9">Z_MSG</h2><pre>function [obj,gstatvec,gevveclen,outoffs]=z_msg(obj,gt,soff,eoff)</pre><pre>WHAT HAPPENS IN Z_MSG?</pre><div><ul><li>message for vector configuration (for hybrid simulation only)</li></ul></div><h2 id="12">Z2_MSG</h2><pre>function obj=z2_msg(obj,gt,ioffs)</pre><pre>WHAT HAPPENS IN Z2_MSG?</pre><div><ul><li>message for vector configuration (for hybrid simulation only)</li><li>second run for setting the index of local input variables</li></ul></div><h2 id="15">SE_MSG</h2><pre>function [obj,event_flag]=se_msg(obj,te,ye,ie)</pre><p>WHAT HAPPENS IN SE_MSG?</p><div><ul><li>state event message</li><li>is called when an state event occurred somewhere in entire model (for hybrid simulation only)</li><li>if state event occured in THIS model, set event_flag and calculate t_next</li></ul></div><p>
<br><br>
<hr>
<br>
<a href="../PDEVS_home.html">DEVS Tbx Home</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="../PDEVS_examples.html">Examples</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="../PDEVS_modelbase.html">Modelbase</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="javascript:history.back()"><< Back</a>
</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Hybrid Atomic Object with Simulator Functionalities
%  stored in DEVS_PATH/00-simulator/hybridatomic.p
%
% Is provided as p-code.


%%
% <html>
% <table border=0><tr><td>Based on modified parallel DEVS
% algorithms (Zeigler, Schwatinski) and wrapper extension (Deatcu).</td></tr>
% <tr><td>All hybrid user defined atomic models have to be derived from class
% hybridatomic.</td></tr>
% <tr><td>C. Deatcu 2016</td></tr></table>
% </html>
%
%% 
classdef hybridatomic < atomic
    %% Description
    % Class definition file for an *associated simulator* for
    % hybrid atomic DEVS models. Extends the discrete associated simulator. 
    %
    % constructor call:  |obj =
    % hybridatomic(name,x,y,s,c_states,elapsed,sysparams)|
    %
    %
    %% Superclass
    % |atomic|
    %
    %% Inherited properties
    %
    % *inherited from devs:*
    %
    % * |sub_of|    : string, name of the superordinate model REPLACE_WITH_DASH_DASH> for debugging purposes
    % * |tnext|     : float, time of next event
    % * |tlast|     : float, time of last event
    % * |name|      : string, (unique) name of this model REPLACE_WITH_DASH_DASH> for debugging purposes
    %                 max. 12 characters for "nice" debug-look ;-)
    % * |x|         : structure, set of inport name/input value (cell array) pairs
    % * |y|         : structure, set of outport name/output value (cell array) pairs
    % * |debug_flag|: 0|1|2|3, no messages|messages|steps|visualize x, y, and s (default 0)
    % * |observe_flag|: 0|1, log states of atomic subcomponents or not (default 0)
    %
    % *inherited from atomic:*
    %
    % * |s|         : structure, set of states
    % * |elapsed|   : float, time elapsed since last 
    %                 transition (only for initialization)
    % * |sysparams| : structure, set of system parameters, can be set only once at instantiation
    % * |observed|  : cell array including time stamps and a copy of s (structure of states)
    %
    %% Properties
    %
    % * |c_states|  : vector of continuous state variables
    % * |mealy|     : 1 if it is of Mealy type, 0 if it is of Moore type
    %                 needs to be set by the modeler in constructor method
    % * |num_c_state_events| : number of cont. state events
    % * |event_offset|    : offset in global event location vector
    % * |state_offset|    : offset in global state vector
    % * |output_offset|   : offset in global output vector
    % * |output_length|   : length of output-vector returned by lamda_c    
    % * |input_offset|     : input offsets in global x vector
    % * |input_length|     : length of input from global x vector
    %
    %% Class methods
    %
    % *inherited from atomic:*
    %
    % *Simulation Messages*
    %
    % * |i_msg(obj,gt)|   : initialization message -
    %   sets tlast and calls tafun() of model to calculate tnext
    % * |s_msg(obj,gt,flag)|: star message - called when atomic is
    %   imminent, calls deltaint() and tafun() of model, sets tlast and
    %   tnext
    % * |x_msg(obj,gt)|  : x message - called, if external event
    %   arrives, calls deltaconffun() or deltaextfun() of model    
    % * |y_msg(obj,gt)|  : inperpellation y message - calls lambdafun
    %   of model
    %
    % *Set Methods for Flags*
    %
    % * |set_debug(obj, debug_flag)|: set flag for debug messages to
    % 0|1|2|3
    % * |set_observe(obj, observe_flag)|: set flag for tracking discrete states to 0|1
    %
    % *Set Methods for States*
    %
    % * |set_states(obj, statenames)|: initializes the structure obj.s. with fields defined in statenames
    % * |set.s(obj,svalues)|:          safe setting of state values in s
    %
    % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
    %
    % *Additional methods for hybrid simulation:*
    %
    % * |[obj,gstatvec,gevveclen,outoffs] = z_msg(obj,gt,soff,eoff)| :
    %   z message - vector configuration of hybrid atomics
    % * |obj = z2_msg(obj,gt,ioffs)| : z2 message - second run vector
    %   configuration of hybrid atomics (setting the index of local input
    %   variables)
    % * |[obj,event_flag] = se_msg(obj,te,ye,ie)| : state event message - 
    %   is called when a state event occurred somewhere in entire model
    %   (for hybrid simulation only);
    %   if state event occured in THIS model, set event_flag and calculate tnext
    %
    % * |showall(obj)|                 : display the object 
    %
    
    properties (Access = public) 
        % HYBRID PROPERTIES
        c_states = []; % vector of continuous state variables
        
        mealy
        num_c_state_events = [];
        event_offset = NaN;     
        state_offset = NaN;         
        output_offset = NaN;    
        output_length = NaN;         
        input_offset = [];
        input_length = [];
        % END HYBRID PROPERTIES        
    end
      
    methods
        function obj = hybridatomic(name,x,y,s,c_states,mealy,elapsed,sysparams) %#ok<INUSL>
            
            if nargin < 8
                error('constructor of base class <<hybridatomic>> failed');
            end
            obj = obj@atomic(name,x,y,s,elapsed,sysparams);% incarnate the associated discrete simulator
            obj.mealy = mealy;        
         end
        
       
        

        %% Z_MSG
        %  function [obj,gstatvec,gevveclen,outoffs]=z_msg(obj,gt,soff,eoff)
        %%
        %  WHAT HAPPENS IN Z_MSG?
        %%
        %
        % * message for vector configuration (for hybrid simulation only)
        %
       function [obj,gstatvec,gevveclen,outoffs]=z_msg(obj,gt,soff,eoff)
            % gt: current time
            % soff: state offset REPLACE_WITH_DASH_DASH> will be set
            % eoff: event offset REPLACE_WITH_DASH_DASH> will be set
            % gstatvec: local state vector for building global state vector
            % gevveclen: number of local state events for calculating
            %            offset in global state event vector
            % outoffs: indexes of continuous output variables in global
            %          state vector
             
            obj.debug_obj.dbprint(gt,110,obj,'');% begin z-msg debug-message
            obj.state_offset = soff;% safe the offset in global state vector HERE LOCALLY
            obj.event_offset = eoff;% safe the offset in global event vector HERE LOCALLY
            
            obj.debug_obj.dbprintcall(gt,6,obj); % call csefunc. debug-message
            ret = cse(obj,-1,0);% call state event condition function with just one input argument
                           % to determine number of possible events
                           % function ret = cse(obj,gt,y)
                         
            %obj.num_c_state_events = length(ret(1));% set number of state events HERE LOCALLY
            %ret(:,1);
            if ~isempty(ret)
            obj.num_c_state_events = length(ret(:,1));% set number of state events HERE LOCALLY
            else
                obj.num_c_state_events = 0;
            end
            
            
            gstatvec = obj.c_states;% return continuous states
            gevveclen = obj.num_c_state_events;% return number of state events
            
            outoffs = (soff+1):(soff+length(gstatvec));% calculate indexes in output vector
                                                       % shift one to the
                                                       % right??????
            obj.debug_obj.dbprint(gt,111,obj,'');% end z-msg debug-message
                                                       
       end
        %% Z2_MSG
        %  function obj=z2_msg(obj,gt,ioffs)
        %%
        %  WHAT HAPPENS IN Z2_MSG?
        %%
        %
        % * message for vector configuration (for hybrid simulation only)
        % * second run for setting the index of local input variables
        %
        function obj = z2_msg(obj,gt,ioffs)
            % gt: current time
            % ioffs: index of first local input variable in global state
            % vector
            obj.debug_obj.dbprint(gt,112,obj,'');% begin z2-msg debug-message
            obj.input_offset = ioffs; % safe the offset HERE LOCALLY
            obj.debug_obj.dbprint(gt,113,obj,'');% end z2-msg debug-message
        end
    
        %% SE_MSG
        %  function [obj,event_flag]=se_msg(obj,te,ye,ie)
        %%
        % WHAT HAPPENS IN SE_MSG?
        %%
        %
        % * state event message
        % * is called when an state event occurred somewhere in entire model (for hybrid simulation only)
        % * if state event occured in THIS model, set event_flag and calculate t_next 
        %  
        function [obj,event_flag]=se_msg(obj,te,ye,ie)
             
            obj.debug_obj.dbprint(te,114,obj,'');% begin se-msg debug-message
            event_flag = 0; % initialize
            if ~isempty (obj.c_states)% if this is a HYBRID atomic
            
            
%             xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
%             if strcmp(obj.name,'bb_1')
%                 obj.c_states(1)=ye(1);
%                 disp('state updated');
%             else
%                 obj.c_states(1)=ye(2);
%             end
%             xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
            if isempty (ie)
               % disp('ye = ')
               % disp(ye);
                obj.c_states=ye(obj.state_offset+1:obj.state_offset+length(obj.c_states),1);
            else
                for idx=1:length(te)
                
                
%                 disp(ie);
%                 disp(obj.state_offset);
%                 disp(length(obj.c_states));
                
                obj.c_states=ye(idx,obj.state_offset+1:obj.state_offset+length(obj.c_states));
                end
                
            
  
       
            
            %disp(['event_offset = ',num2str(obj.event_offset)]);
            lower_e_idx = obj.event_offset + 1;
            %disp(['num_c_state_event = ',num2str(obj.num_c_state_events)]);
            upper_e_idx = obj.event_offset + obj.num_c_state_events;

            % put back continuous value
            % obj.c_state = ye (lower_s_idx:upper_s_idx);
            

            for idx=1:length(te)
                %disp(['ie = ', num2str(ie)]);
                
                if lower_e_idx <= ie(idx) && ie(idx) <= upper_e_idx % if event occured HERE
                   event_number_in_model = ie(idx) - lower_e_idx +1;

                %deltastatefun(asubs{k},te(i),ye(i,gstat_offset(k)+1:gstat_offset(k)+gstat_length(k)));
                %bei Aufruf aus root coordinator wie oben
                %
                obj.debug_obj.dbprintcall(te,7,obj); % call deltastatefun debug-message
                
                %disp(ye(idx,obj.state_offset+1:obj.state_offset+length(obj.c_states)));
                %disp(['event_number_in_model: ',num2str(event_number_in_model)]);
                deltastatefun(obj,te(idx),ye(idx,obj.state_offset+1:obj.state_offset+length(obj.c_states)),event_number_in_model);
                
	
                %obj.elapsed_time = te - obj.t_last;
                %obj = delta_state (obj, ie - lower_e_idx + 1);
                %obj.elapsed_time = 0;
                
                obj.tlast = te(idx);
                %obj.elapsed = 0;% ????????????????
                obj.debug_obj.dbprintcall(te,1,obj); % call ta-fun debug-message
                obj.tnext = obj.tlast + tafun(obj);
                event_flag = 1;   % event occured in THIS object
                end
            end
                
                %end
                
            end
            end
         obj.debug_obj.dbprint(te,115,obj,'');% end se-msg debug-message
        end
        %######################## end SIMULATOR FUNCTIONS #######################
        
        
        %######################### DISPLAY HELPER FUNCTIONS #########################
        % Functions for displaying the hybrid atomic objects
        % 
        % * |function showxports(obj)|: display x-ports
        % * |function showyports(obj)|: display y-ports
        % * |showstates(obj)|: display states in s
        % * |showcontstates(obj)|: display continuous states
        %
        % This functions *can* be called to get some information during
        % or after simulation.       

                
        function showcontstates(obj)
            disp('Vec. of cont. states c_states'),disp('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH'),disp(obj.c_states);
        end
        
        function showall(obj)
            disp(obj);
            fprintf(1,'\n');
            showxports(obj);
            showyports(obj);
            showstates(obj);
            showcontstates(obj);
        end
        %####################### end DISPLAY HELPER FUNCTIONS #######################
        
    end
end
%%
%
%
%
% <html>
% <br><br>
% <hr>
% <br>
% <a href="../PDEVS_home.html">DEVS Tbx Home</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
% <a href="../PDEVS_examples.html">Examples</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
% <a href="../PDEVS_modelbase.html">Modelbase</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
% <a href="javascript:history.back()"><< Back</a>
% </html>



##### SOURCE END #####
--></body></html>